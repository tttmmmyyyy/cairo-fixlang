module Cairo;

// The cairo drawing context.
type Cairo = unbox struct { _dtor : Destructor _CairoHandle };

type _CairoHandle = Ptr;

_with_handle : (_CairoHandle -> a) -> Cairo -> a;
_with_handle = |act, cairo| cairo.@_dtor.borrow(act);

create : Surface -> Cairo;
create = |surface| (
    surface._with_handle(|surface| (
        let handle = CALL_C[Ptr cairo_create(Ptr), surface];
        Cairo { _dtor : Destructor::make(handle, |handle| (
            CALL_C[() cairo_destroy(Ptr), handle]
        )) }
    ))
);

// TODO: add get_status function.

save : Cairo -> IO ();
save = |cairo| IO::from_func $ |_| cairo._with_handle(|cairo| (
        CALL_C[() cairo_save(Ptr), cairo]
));

restore : Cairo -> IO ();
restore = |cairo| IO::from_func $ |_| cairo._with_handle(|cairo| (
        CALL_C[() cairo_restore(Ptr), cairo]
));

get_target : Cairo -> Surface;
get_target = |cairo| cairo._with_handle(|cairo| (
    let surface = CALL_C[Ptr cairo_get_target(Ptr), cairo];
    eval CALL_C[Ptr cairo_surface_reference(Ptr), surface];
    Surface::_create_from_handle(surface)
));

push_group : Cairo -> IO ();
push_group = |cairo| IO::from_func $ |_| cairo._with_handle(|cairo| (
        CALL_C[() cairo_push_group(Ptr), cairo]
));

push_group_with_content : Content -> Cairo -> IO ();
push_group_with_content = |content, cairo| IO::from_func $ |_| cairo._with_handle(|cairo| (
        CALL_C[() cairo_push_group_with_content(Ptr, I32), cairo, content]
));

pop_group : Cairo -> IO Pattern;
pop_group = |cairo| IO::from_func $ |_| cairo._with_handle(|cairo| (
    let pattern = CALL_C[Ptr cairo_pop_group(Ptr), cairo];
    Pattern::_create_from_handle(pattern)
));

pop_group_to_source : Cairo -> IO ();
pop_group_to_source = |cairo| IO::from_func $ |_| cairo._with_handle(|cairo| (
        CALL_C[() cairo_pop_group_to_source(Ptr), cairo]
));

get_group_target : Cairo -> IO Surface;
get_group_target = |cairo| IO::from_func $ |_| cairo._with_handle(|cairo| (
    let surface = CALL_C[Ptr cairo_get_group_target(Ptr), cairo];
    eval CALL_C[Ptr cairo_surface_reference(Ptr), surface];
    Surface::_create_from_handle(surface)
));

select_font_face : String -> FontSlant -> FontWeight -> Cairo -> IO ();
select_font_face = |font, slant, weight, cairo| IO::from_func $ |_| (
    cairo._with_handle(|cairo| (
        font.borrow_c_str(|font| (
            CALL_C[() cairo_select_font_face(Ptr, Ptr, I32, I32), cairo, font, slant, weight]
        ))
    ))
);

set_font_size : F64 -> Cairo -> IO ();
set_font_size = |size, cairo| IO::from_func $ |_| (
    cairo._with_handle(|cairo| (
        CALL_C[() cairo_set_font_size(Ptr, F64), cairo, size]
    ))
);

set_source_rgb : F64 -> F64 -> F64 -> Cairo -> IO ();
set_source_rgb = |r, g, b, cairo| IO::from_func $ |_| (
    cairo._with_handle(|cairo| (
        CALL_C[() cairo_set_source_rgb(Ptr, F64, F64, F64), cairo, r, g, b]
    ))
);

move_to : F64 -> F64 -> Cairo -> IO ();
move_to = |x, y, cairo| IO::from_func $ |_| (
    cairo._with_handle(|cairo| (
        CALL_C[() cairo_move_to(Ptr, F64, F64), cairo, x, y]
    ))    
);

show_text : String -> Cairo -> IO ();
show_text = |text, cairo| IO::from_func $ |_| (
    cairo._with_handle(|cairo| (
        text.borrow_c_str(|text| (
            CALL_C[() cairo_show_text(Ptr, Ptr), cairo, text]
        ))
    ))
);

namespace Surface {
    type Surface = unbox struct { _dtor : Destructor (_SurfaceHandle) };

    type _SurfaceHandle = Ptr;

    _with_handle : (_SurfaceHandle -> a) -> Surface -> a;
    _with_handle = |act, surface| surface.@_dtor.borrow(act);

    _create_from_handle : _SurfaceHandle -> Surface;
    _create_from_handle = |handle| Surface { _dtor : Destructor::make(handle, |handle| CALL_C[() cairo_surface_destroy(Ptr), handle]) };

    create_image_surface : Format -> I64 -> I64 -> Surface;
    create_image_surface = |format, width, height| (
        let handle = CALL_C[Ptr cairo_image_surface_create(I32, I32, I32), format, width.to_I32, height.to_I32];
        Surface::_create_from_handle(handle)
    );

    write_to_png : Path -> Surface -> IO ();
    write_to_png = |path, surface| IO::from_func $ |_| (
        surface._with_handle(|surface| (
            path.to_string.borrow_c_str(|path| (
                CALL_C[() cairo_surface_write_to_png(Ptr, Ptr), surface, path]
            )) 
        ))
    );
}

namespace Pattern {
    type Pattern = unbox struct { _dtor : Destructor _PatternHandle };

    type _PatternHandle = Ptr;

    _with_handle : (_PatternHandle -> a) -> Pattern -> a;
    _with_handle = |act, pattern| pattern.@_dtor.borrow(act);

    _create_from_handle : _PatternHandle -> Pattern;
    _create_from_handle = |handle| Pattern { _dtor : Destructor::make(handle, |handle| CALL_C[() cairo_pattern_destroy(Ptr), handle]) };
}

namespace Content {
    type Content = I32;

    color : Content;
    color = 0x1000_I32;

    alpha : Content;
    alpha = 0x2000_I32;

    color_alpha : Content;
    color_alpha = 0x3000_I32;
}

namespace Format {
    type Format = I32;

    argb : Format;
    argb = 0_I32;

    rgb24 : Format;
    rgb24 = 1_I32;

    a8 : Format;
    a8 = 2_I32;

    a1 : Format;
    a1 = 3_I32;

    rgb16_565 : Format;
    rgb16_565 = 4_I32;

    rgb30 : I32;
    rgb30 = 5_I32;
}


namespace FontSlant {
    type FontSlant = I32;

    normal : FontSlant;
    normal = 0_I32;

    italic : FontSlant;
    italic = 1_I32;

    oblique : FontSlant;
    oblique = 2_I32;
}

namespace FontWeight {
    type FontWeight = I32;

    normal : FontWeight;
    normal = 0_I32;

    bold : FontWeight;
    bold = 1_I32;
}