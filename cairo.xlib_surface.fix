module Cairo.XlibSurface;

import Cairo::{Surface, Surface::_create_from_handle};

type _DisplayHandle = Ptr;
type _WindowId = U64;
type _BackBufferId = U64;

type Window = box struct { 
    _display : _DisplayHandle,
    _window_id : _WindowId,
    width : I32,
    height : I32
};

create_simple_window : (I64, I64) -> IO Window;
create_simple_window = |(width, height)| IO::from_func $ |_| (
    let width = width.to_I32;
    let height = height.to_I32;
    let display : _DisplayHandle = CALL_C[Ptr XOpenDisplay(Ptr), nullptr];
    let window : _WindowId = CALL_C[U64 cairo_fixlang_xlib_surface_create_x_window(Ptr, I32, I32), display, width, height];
    Window { _display : display, _window_id : window, width : width, height : height }
);

destroy_window : Window -> IO ();
destroy_window = |window| IO::from_func $ |_| (
    eval CALL_C[() XDestroyWindow(Ptr, U64), window.@_display, window.@_window_id];
    CALL_C[() XCloseDisplay(Ptr), window.@_display]
);

create_front_surface : Window -> Surface;
create_front_surface = |window| (
    let handle = CALL_C[Ptr cairo_fixlang_xlib_surface_create_x_surface(Ptr, U64, I32, I32), window.@_display, window.@_window_id, window.@width, window.@height];
    Surface::_create_from_handle(handle)
);

create_back_surface : Window -> Surface;
create_back_surface = |window| (
    let back_buffer = CALL_C[U64 XdbeAllocateBackBufferName(Ptr, U64, U8), window.@_display, window.@_window_id, XbeSwapAction::undefined];
    let handle = CALL_C[Ptr cairo_fixlang_xlib_surface_create_x_surface(Ptr, U64, I32, I32), window.@_display, back_buffer, window.@width, window.@height];
    Surface::_create_from_handle(handle)
);

swap_buffers : XbeSwapAction -> Window -> IO ();
swap_buffers = |swap_action, window| IO::from_func $ |_| (
    let swap_action = [(window.@_window_id, swap_action)];
    swap_action.borrow_ptr(|swap_action| 
        CALL_C[() XdbeSwapBuffers(Ptr, Ptr, I32), window.@_display, swap_action, 1_I32]
    )
);

flush : Window -> IO ();
flush = |window| IO::from_func $ |_| CALL_C[() XFlush(Ptr), window.@_display];

next_event : Window -> IO Event;
next_event = |window| IO::from_func $ |_| (
    let event_ptr = CALL_C[Ptr cairo_fixlang_xlib_next_event(Ptr), window.@_display];
    let event = Destructor::make(event_ptr, |event_ptr| CALL_C[() cairo_fixlang_xlib_free_event(Ptr), event_ptr]);
    event.borrow(|event_ptr| 
        let event_type = CALL_C[I32 cairo_fixlang_xlib_event_type(Ptr), event_ptr];
        if event_type == Event::_expose_id {
            let expose_event = [ExposeEvent::_null]; // TODO: we should add `Array::unsafe_uninitialized`, or `borrow_ptr` for any boxed type.
            eval expose_event.borrow_ptr(|expose_event_ptr|
                CALL_C[() cairo_fixlang_xlib_as_expose_event(Ptr, Ptr), event_ptr, expose_event_ptr]
            );
            Event::expose(expose_event.@(0))
        } else if event_type == Event::_destroy_notify_id {
            let destroy_notify_event = [DestroyNotifyEvent::_null];
            eval destroy_notify_event.borrow_ptr(|destroy_notify_event_ptr|
                CALL_C[() cairo_fixlang_xlib_as_destroy_notify_event(Ptr, Ptr), event_ptr, destroy_notify_event_ptr]
            );
            Event::destroy_notify(destroy_notify_event.@(0))
        } else if event_type == Event::_button_press_id {
            let button_press_event = [ButtonEvent::_null];
            eval button_press_event.borrow_ptr(|button_press_event_ptr|
                CALL_C[() cairo_fixlang_xlib_as_button_event(Ptr, Ptr), event_ptr, button_press_event_ptr]
            );
            Event::button_press(button_press_event.@(0))
        } else if event_type == Event::_button_release_id {
            let button_release_event = [ButtonEvent::_null];
            eval button_release_event.borrow_ptr(|button_release_event_ptr|
                CALL_C[() cairo_fixlang_xlib_as_button_event(Ptr, Ptr), event_ptr, button_release_event_ptr]
            );
            Event::button_release(button_release_event.@(0))
        } else if event_type == Event::_motion_notify_id {
            let motion_notify_event = [MotionEvent::_null];
            eval motion_notify_event.borrow_ptr(|motion_notify_event_ptr|
                CALL_C[() cairo_fixlang_xlib_as_motion_notify_event(Ptr, Ptr), event_ptr, motion_notify_event_ptr]
            );
            Event::motion_notify(motion_notify_event.@(0))
        } else {
            Event::unimplemented()
        }
    )
);

select_input : EventMask -> Window -> IO ();
select_input = |event_mask, window| IO::from_func $ |_| (
    CALL_C[() XSelectInput(Ptr, U64, U64), window.@_display, window.@_window_id, event_mask]
);

events_queued : QueuedMode -> Window -> IO I64;
events_queued = |mode, window| IO::from_func $ |_| (
    CALL_C[I32 XEventsQueued(Ptr, I32), window.@_display, mode].to_I64
);

type QueuedMode = I32;

namespace QueuedMode {
    already : QueuedMode;
    already = 0_I32;

    reading : QueuedMode;
    reading = 1_I32;

    after_flush : QueuedMode;
    after_flush = 2_I32;
}

type XbeSwapAction = U8;

namespace XbeSwapAction {
    undefined : XbeSwapAction;
    undefined = 0_U8;

    background : XbeSwapAction;
    background = 1_U8;

    untouched : XbeSwapAction;
    untouched = 2_U8;

    copied : XbeSwapAction;
    copied = 3_U8;
}

type Event = box union {
    button_press : ButtonEvent,
    button_release : ButtonEvent,
    motion_notify : MotionEvent,
    expose : ExposeEvent,
    destroy_notify : DestroyNotifyEvent,
    unimplemented : (),
};

namespace Event {
    _button_press_id : I32;
    _button_press_id = 4_I32;

    _button_release_id : I32;
    _button_release_id = 5_I32;

    type ButtonEvent = unbox struct {
        type_ : I32,
        serial : U64,
        send_event : I32,
        _display : Ptr,
        _window : U64,
        _root : U64,
        _subwindow : U64,
        time : U64,
        x : I32,
        y : I32,
        x_root : I32,
        y_root : I32,
        state : U64,
        button : U32,
        same_screen : I32
    };

    namespace ButtonEvent {
        _null : ButtonEvent;
        _null = ButtonEvent { type_ : 0_I32, serial : 0_U64, send_event : 0_I32, _display : nullptr, _window : 0_U64, _root : 0_U64, _subwindow : 0_U64, time : 0_U64, x : 0_I32, y : 0_I32, x_root : 0_I32, y_root : 0_I32, state : 0_U64, button : 0_U32, same_screen : 0_I32 };
    }

    _motion_notify_id : I32;
    _motion_notify_id = 6_I32;

    type MotionEvent = unbox struct {
        type_ : I32,
        serial : U64,
        send_event : I32,
        _display : Ptr,
        _window : U64,
        _root : U64,
        _subwindow : U64,
        time : U64,
        x : I32,
        y : I32,
        x_root : I32,
        y_root : I32,
        state : U64,
        is_hint : U8,
        same_screen : I32
    };

    namespace MotionEvent {
        _null : MotionEvent;
        _null = MotionEvent { type_ : 0_I32, serial : 0_U64, send_event : 0_I32, _display : nullptr, _window : 0_U64, _root : 0_U64, _subwindow : 0_U64, time : 0_U64, x : 0_I32, y : 0_I32, x_root : 0_I32, y_root : 0_I32, state : 0_U64, is_hint : 0_U8, same_screen : 0_I32 };
    }

    _expose_id : I32;
    _expose_id = 12_I32;

    type ExposeEvent = unbox struct {
        type_ : I32,
        serial : U64,
        send_event : I32,
        _display : Ptr,
        _window : U64,
        x : I32,
        y : I32,
        width : I32,
        height : I32,
        count : I32
    };

    namespace ExposeEvent {
        _null : ExposeEvent;
        _null = ExposeEvent { type_ : 0_I32, serial : 0_U64, send_event : 0_I32, _display : nullptr, _window : 0_U64, x : 0_I32, y : 0_I32, width : 0_I32, height : 0_I32, count : 0_I32 };
    }

    _destroy_notify_id : I32;
    _destroy_notify_id = 17_I32;

    type DestroyNotifyEvent = unbox struct {
        type_ : I32,
        serial : U64,
        send_event : I32,
        _display : Ptr,
        _event : U64,
        _window : U64
    };

    namespace DestroyNotifyEvent {
        _null : DestroyNotifyEvent;
        _null = DestroyNotifyEvent { type_ : 0_I32, serial : 0_U64, send_event : 0_I32, _display : nullptr, _event : 0_U64, _window : 0_U64 };
    }
}

type EventMask = U64;

namespace EventMask {
    button_press : EventMask;
    button_press = 1_U64.shift_left(2_U64);

    button_release : EventMask;
    button_release = 1_U64.shift_left(3_U64);

    pointer_motion : EventMask;
    pointer_motion = 1_U64.shift_left(6_U64);

    exposure : EventMask;
    exposure = 1_U64.shift_left(15_U64);

    structure_notify : EventMask;
    structure_notify = 1_U64.shift_left(17_U64);    
}