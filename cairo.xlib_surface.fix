module Cairo.XlibSurface;

import Cairo::{Surface, Surface::_create_from_handle};

type _DisplayHandle = Ptr;
type _WindowId = U64;
type _BackBufferId = U64;

type Window = box struct { 
    _display : _DisplayHandle,
    _window_id : _WindowId,
    width : I32,
    height : I32
};

create_simple_window : (I64, I64) -> IO Window;
create_simple_window = |(width, height)| IO::from_func $ |_| (
    let width = width.to_I32;
    let height = height.to_I32;
    let display : _DisplayHandle = CALL_C[Ptr XOpenDisplay(Ptr), nullptr];
    let window : _WindowId = CALL_C[U64 cairo_fixlang_xlib_surface_create_x_window(Ptr, I32, I32), display, width, height];
    Window { _display : display, _window_id : window, width : width, height : height }
);

destroy_window : Window -> IO ();
destroy_window = |window| IO::from_func $ |_| (
    eval CALL_C[() XDestroyWindow(Ptr, U64), window.@_display, window.@_window_id];
    CALL_C[() XCloseDisplay(Ptr), window.@_display]
);

create_front_surface : Window -> Surface;
create_front_surface = |window| (
    let handle = CALL_C[Ptr cairo_fixlang_xlib_surface_create_x_surface(Ptr, U64, I32, I32), window.@_display, window.@_window_id, window.@width, window.@height];
    Surface::_create_from_handle(handle)
);

create_back_surface : Window -> Surface;
create_back_surface = |window| (
    let back_buffer = CALL_C[U64 XdbeAllocateBackBufferName(Ptr, U64, U8), window.@_display, window.@_window_id, XbeSwapAction::undefined];
    let handle = CALL_C[Ptr cairo_fixlang_xlib_surface_create_x_surface(Ptr, U64, I32, I32), window.@_display, back_buffer, window.@width, window.@height];
    Surface::_create_from_handle(handle)
);

swap_buffers : XbeSwapAction -> Window -> IO ();
swap_buffers = |swap_action, window| IO::from_func $ |_| (
    let swap_action = [(window.@_window_id, swap_action)];
    swap_action.borrow_ptr(|swap_action| 
        CALL_C[() XdbeSwapBuffers(Ptr, Ptr, I32), window.@_display, swap_action, 1_I32]
    )
);

flush : Window -> IO ();
flush = |window| IO::from_func $ |_| CALL_C[() XFlush(Ptr), window.@_display];

next_event : Window -> IO Event;
next_event = |window| IO::from_func $ |_| (
    let event_ptr = CALL_C[Ptr cairo_fixlang_xlib_next_event(Ptr), window.@_display];
    let event = Destructor::make(event_ptr, |event_ptr| CALL_C[() cairo_fixlang_xlib_free_event(Ptr), event_ptr]);
    event.borrow(|event_ptr| 
        let event_type = CALL_C[I32 cairo_fixlang_xlib_event_type(Ptr), event_ptr];
        if event_type == Event::_expose_id {
            let expose_event = [ExposeEvent::_null]; // TODO: we should add `Array::unsafe_uninitialized`, or `borrow_ptr` for any boxed type.
            eval expose_event.borrow_ptr(|expose_event_ptr|
                CALL_C[() cairo_fixlang_xlib_as_expose_event(Ptr, Ptr), event_ptr, expose_event_ptr]
            );
            Event::expose(expose_event.@(0))
        } else if event_type == Event::_destroy_notify_id {
            let destroy_notify_event = [DestroyNotifyEvent::_null];
            eval destroy_notify_event.borrow_ptr(|destroy_notify_event_ptr|
                CALL_C[() cairo_fixlang_xlib_as_destroy_notify_event(Ptr, Ptr), event_ptr, destroy_notify_event_ptr]
            );
            Event::destroy_notify(destroy_notify_event.@(0))
        } else {
            Event::unimplemented()
        }
    )
);

select_input : EventMask -> Window -> IO ();
select_input = |event_mask, window| IO::from_func $ |_| (
    CALL_C[() XSelectInput(Ptr, U64, U64), window.@_display, window.@_window_id, event_mask]
);

type XbeSwapAction = U8;

namespace XbeSwapAction {
    undefined : XbeSwapAction;
    undefined = 0_U8;

    background : XbeSwapAction;
    background = 1_U8;

    untouched : XbeSwapAction;
    untouched = 2_U8;

    copied : XbeSwapAction;
    copied = 3_U8;
}

type Event = box union {
    expose : ExposeEvent,
    destroy_notify : DestroyNotifyEvent,
    unimplemented : (),
};

namespace Event {
    _expose_id : I32;
    _expose_id = 12_I32;

    type ExposeEvent = unbox struct {
        type_ : I32,
        serial : U64,
        send_event : I32,
        _display : Ptr,
        _window : U64,
        x : I32,
        y : I32,
        width : I32,
        height : I32,
        count : I32
    };

    namespace ExposeEvent {
        _null : ExposeEvent;
        _null = ExposeEvent { type_ : 0_I32, serial : 0_U64, send_event : 0_I32, _display : nullptr, _window : 0_U64, x : 0_I32, y : 0_I32, width : 0_I32, height : 0_I32, count : 0_I32 };
    }

    _destroy_notify_id : I32;
    _destroy_notify_id = 17_I32;

    type DestroyNotifyEvent = unbox struct {
        type_ : I32,
        serial : U64,
        send_event : I32,
        _display : Ptr,
        _event : U64,
        _window : U64
    };

    namespace DestroyNotifyEvent {
        _null : DestroyNotifyEvent;
        _null = DestroyNotifyEvent { type_ : 0_I32, serial : 0_U64, send_event : 0_I32, _display : nullptr, _event : 0_U64, _window : 0_U64 };
    }
}

type EventMask = U64;

namespace EventMask {
    exposure : EventMask;
    exposure = 1_U64.shift_left(15_U64);

    structure_notify : EventMask;
    structure_notify = 1_U64.shift_left(17_U64);    
}