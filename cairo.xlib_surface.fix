module Cairo.Surface.Xlib;

import Cairo::Surface;

type _DisplayHandle = Ptr;
type _WindowId = U64;

type Window = box struct { _display : _DisplayHandle, _window_id : _WindowId, width : I32, height : I32 };

create_window : I64 -> I64 -> IO Window;
create_window = |width, height| IO::from_func $ |_| (
    let width = width.to_I32;
    let height = height.to_I32;
    let display : _DisplayHandle = CALL_C[Ptr XOpenDisplay(Ptr), nullptr];
    let window : _WindowId = CALL_C[U64 cairo_fixlang_xlib_surface_create_x_window(Ptr, I32, I32), display, width, height];
    Window { _display : display, _window_id : window, width : width, height : height }
);

close_window : Window -> IO ();
close_window = |window| IO::from_func $ |_| (
    eval CALL_C[() XDestroyWindow(Ptr, U64), window.@_display, window.@_window_id];
    CALL_C[() XCloseDisplay(Ptr), window.@_display]
);

create_surface : Window -> Surface;
create_surface = |window| (
    let handle = CALL_C[Ptr cairo_fixlang_xlib_surface_create_x_surface(Ptr, U64, I32, I32), window.@_display, window.@_window_id, window.@width, window.@height];
    Surface::_create_from_handle(handle)
);

flush : Window -> IO ();
flush = |window| IO::from_func $ |_| CALL_C[() XFlush(Ptr), window.@_display];