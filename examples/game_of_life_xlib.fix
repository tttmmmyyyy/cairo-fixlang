module Main;

import Cairo;
import Cairo.XlibSurface;
import Time;
import Random;
import Debug;

cells_count : (I64, I64);
cells_count = (200, 200);

cell_size : (I64, I64);
cell_size = (3, 3);

window_size : (I64, I64);
window_size = (cells_count.@0 * cell_size.@0, cells_count.@1 * cell_size.@1);

fps : F64;
fps = 60.0;

type GameState = box struct {
    prev_state : Array (Array Bool),
    current_state : Array (Array Bool),
};

namespace GameState {
    initialize : GameState;
    initialize = (
        let prev_state = Array::fill(cells_count.@0, Array::fill(cells_count.@1, false));
        let current_state = Array::fill(cells_count.@0, Array::fill(cells_count.@1, false));
        GameState {
            prev_state : prev_state,
            current_state : current_state,
        }
    );

    randomize : Random -> GameState -> (GameState, Random);
    randomize = |rand, state| (
        Iterator::range(0, cells_count.@0).product(Iterator::range(0, cells_count.@1)).fold((state, rand), |(state, rand), (x, y)|
            let (alive, rand) = rand.generate_U64;
            let alive = alive % 2_U64 == 0_U64;
            let state = state.mod_current_state(|current| current.mod(x, set(y, alive)));
            (state, rand)
        )
    );

    proceed_cells : GameState -> GameState;
    proceed_cells = |state| (
        let state = state.swap;
        let state = state.update_current;
        state
    );

    swap : GameState -> GameState;
    swap = |state| (
        let current_state = state.@current_state;
        let prev_state = state.@prev_state;
        state.set_prev_state(current_state).set_current_state(prev_state)
    );

    update_current : GameState -> GameState;
    update_current = |state| (
        let prev = state.@prev_state;
        state.mod_current_state(|current| (
            let cells = cells_count.@0 * cells_count.@1;
            loop((0, current), |(pos, current)|
                if pos == cells { break $ current };
                let y = pos % cells_count.@1;
                let x = pos / cells_count.@1;
                let count = loop((0, 0), |(d, acc)|
                    if d == 9 { break $ acc };
                    let dx = d % 3 - 1;
                    let dy = d / 3 - 1;
                    if dx == 0 && dy == 0 { continue $ (d + 1, acc) };
                    let x = (x + dx + cells_count.@0) % cells_count.@0;
                    let y = (y + dy + cells_count.@1) % cells_count.@1;
                    let acc = acc + if prev.@(x).@(y) { 1 } else { 0 };
                    continue $ (d + 1, acc)
                );
                let alive = if prev.@(x).@(y) {
                    count == 2 || count == 3
                } else {
                    count == 3
                };
                let current = current.mod(x, set(y, alive));
                continue $ (pos + 1, current)
            )
        ))
    );

    render : Cairo -> GameState -> IO ();
    render = |cairo, state| (
        eval *cairo.set_source_rgb((1.0, 1.0, 1.0));

        eval *Iterator::range(0, cells_count.@1).product(Iterator::range(0, cells_count.@0)).loop_iter_m((), |_, (y, x)|
            let is_alive = state.@current_state.@(x).@(y);

            eval *if is_alive {   
                let pos = ((x * cell_size.@0).to_F64, (y * cell_size.@1).to_F64);
                let cell_size = (cell_size.@0.to_F64, cell_size.@1.to_F64);
                cairo.rectangle(pos, cell_size)
            } else {
                pure()
            };

            continue_m $ ()
        );

        eval *cairo.fill;
        pure()
    );
}

main : IO ();
main = (
    let window = *XlibSurface::create_simple_window(window_size);
    let event_mask = EventMask::exposure;
    eval *window.select_input(event_mask);
    // Wait for the window to be exposed.
    eval *loop_m((), |_| (
        let event = *window.next_event;
        if event.is_expose { break_m $ () };
        continue_m $ ()
    ));
    
    let surface = XlibSurface::create_back_surface(window);
    let cairo = Cairo::create(surface);

    let time = (*Time::get_now_monotonic).to_F64;
    let rand = Random::init_by_seed(time.to_U64);
    let (state, _rand) = GameState::initialize.randomize(rand);

    eval *loop_m((state, time), |(state, prev_time)|
        let now_time = (*Time::get_now_monotonic).to_F64;
        if now_time - prev_time < 1.0 / fps { continue_m $ (state, prev_time) };

        let (state, time) = consumed_time_while_lazy(|_| state.proceed_cells);
        eval *println(time.to_string);

        eval *state.render(cairo);
        eval *window.flush;
        eval *window.swap_buffers(XbeSwapAction::background);

        continue_m $ (state, now_time)
    );

    eval *window.destroy_window;

    pure()
);